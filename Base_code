import requests  # sūta HTTP pieprasījumu uz saiti
from bs4 import BeautifulSoup  # parsē HTML
import concurrent.futures  # paralēlai lappušu lādēšanai, ātrāka pārmeklēšana

BASE_URL = 'https://books.toscrape.com/'  # saite kuru webscrape

def get_soup(url):
    res = requests.get(url)  # sūta pieprasījumu uz URL
    return BeautifulSoup(res.text, 'html.parser')  # parse HTML izmantojot BeautifulSoup

def get_categories():
    soup = get_soup(BASE_URL)
    category_section = soup.find('div', class_='side_categories')  # atrod saites kategoriju sadaļu
    links = category_section.find_all('a')[1:]  # izlaiž pirmo sadaļu "Books" un dodas uz kategorijām
    categories = {i + 1: (link.text.strip(), BASE_URL + link['href']) for i, link in enumerate(links)}  #
    return categories

def rating_to_number(star_text):
    ratings = {
        'One': 1,
        'Two': 2,
        'Three': 3,
        'Four': 4,
        'Five': 5
    }
    return ratings.get(star_text, 0)  # atgriež reitingu skaitlī, ja nav atrasts – 0

def get_books_from_category(url):  # palīdzfunkcija, kas pārmeklē visas lappuses izvēlētajā kategorijā
    books = []
    page = 1
    while True:
        if page == 1:
            paged_url = url  # pirmajai lapai izmanto index.html
        else:
            paged_url = url.replace('index.html', f'page-{page}.html')  # nākamajām lapām izmanto page-2.html utt.
        res = requests.get(paged_url)
        if res.status_code != 200:
            break
        soup = BeautifulSoup(res.text, 'html.parser')
        page_books = soup.find_all('article', class_='product_pod')  # atrod grāmatas lapā
        if not page_books:
            break
        books.extend(page_books)
        page += 1
    return books

def search_by_category():
    categories = get_categories()
    print("\nPieejamās kategorijas:")  # izvadīt pieejamās kategorijas no vietnes
    for i, (name, _) in categories.items():
        print(f"{i}. {name}")
    try:
        selected = int(input("\nIzvēlieties kategorijas numuru: ").strip())  # ievada izvēlēto kategoriju 1-50
        name, url = categories.get(selected, (None, None))
        if not name:
            print("Nederīgs numurs.")
            return
        print(f"\nGrāmatas kategorijā '{name}':")

        books = get_books_from_category(url)  # iegūst visas grāmatas no izvēlētās kategorijas
        for book in books:
            title = book.h3.a['title']  # ņemt šīs grāmatas nosaukumu
            print(f" - {title}")

    except ValueError:
        print("Ievadiet ciparu.")  # kļūda, ja nav ievadīts cipars vai cipars, kas nav sarakstā

def search_by_rating():
    categories = get_categories()
    print("\nPieejamās kategorijas:")
    for i, (name, _) in categories.items():
        print(f"{i}. {name}")
    try:
        selected = int(input("\nIzvēlieties kategorijas numuru: ").strip())  # izvēlies kategoriju
        name, url = categories.get(selected, (None, None))
        if not name:
            print("Nederīgs kategorijas numurs.")
            return

        try:
            target_rating = int(input("Ievadiet reitingu (1-5): ").strip())  # izvēlēties cik lielu reitingu meklēt
            if target_rating not in range(1, 6):
                raise ValueError
        except ValueError:
            print("Ievadiet skaitli no 1 līdz 5.")
            return

        print(f"\nGrāmatas ar {target_rating} zvaigznēm kategorijā '{name}':")
        books = get_books_from_category(url)  # meklēt tikai izvēlētajā kategorijā
        found = False
        for book in books:
            rating_class = book.p['class'][1]  # atrast reitingu, kas izvēlēts
            rating = rating_to_number(rating_class)
            if rating == target_rating:
                title = book.h3.a['title']
                print(f" - {title}")
                found = True
        if not found:
            print("Nav atrastu grāmatu ar šo reitingu šajā kategorijā.")

    except ValueError:
        print("Ievadiet ciparu.")

def search_by_price():
    try:
        min_price = float(input("Min cena: ").strip())  # ievada minimālo cenu
        max_price = float(input("Max cena: ").strip())  # ievada maksimālo cenu
    except ValueError:
        print("Nederīga cena.")
        return

    print(f"\nGrāmatas cenā starp £{min_price} un £{max_price}:")
    categories = get_categories()
    for name, url in categories.values():
        books = get_books_from_category(url)
        for book in books:
            price_tag = book.find('p', class_='price_color')  # atrast cenu
            price_text = price_tag.text.encode('ascii', 'ignore').decode().replace('£', '').strip()  # iztīrīt simbolus
            try:
                price = float(price_text)
            except ValueError:
                continue
            if min_price <= price <= max_price:
                title = book.h3.a['title']
                print(f" - {title} (£{price}) [{name}]")  # izvada arī kategoriju

def search_by_name():
    search_term = input("Ievadiet grāmatas nosaukumu (vai daļu no tā): ").strip().lower()  # ievada meklējamo nosaukumu
    max_pages = 50  # Books.toscrape ir 50 katalogu lappuses
    found_books = []

    def fetch_and_search(page):
        url = BASE_URL + f'catalogue/page-{page}.html'
        try:
            res = requests.get(url, timeout=5)
            if res.status_code != 200:
                return []
            soup = BeautifulSoup(res.text, 'html.parser')
            books = soup.find_all('article', class_='product_pod')
            matches = []
            for book in books:
                title = book.h3.a['title']
                if search_term in title.lower():  # pārbauda, vai ievadītā frāze atrodas nosaukumā
                    matches.append(title)
            return matches
        except requests.RequestException:
            return []  # ja netiek izvadīts nekas

    with concurrent.futures.ThreadPoolExecutor() as executor:  # meklē lappuses paralēli, izdarot darbu ātrāk
        futures = [executor.submit(fetch_and_search, page) for page in range(1, max_pages + 1)]
        for future in concurrent.futures.as_completed(futures):
            found_books.extend(future.result())

    if found_books:
        print("\nAtrastas grāmatas:")
        for title in found_books:
            print(f" - {title}")
    else:
        print("Netika atrasta neviena grāmata ar šādu nosaukumu.")

def main():
    try:
        while True:
            print("\nMetodes:")
            print("1. Kategorija")
            print("2. Reitings")
            print("3. Cena")
            print("4. Atrast")
            print("5. Beigt darbu")  
            choice = input("Izvēlieties darbību (1-5): ").strip()

            if choice == '1':
                search_by_category()
            elif choice == '2':
                search_by_rating()
            elif choice == '3':
                search_by_price()
            elif choice == '4':
                search_by_name()
            elif choice == '5':
                print("Darbs pārtraukts.")
                break
            else:
                print("Nederīga izvēle.")
    except KeyboardInterrupt:
        print("\nProgramma pārtraukta lietotāja pieprasījumā.")

if __name__ == "__main__":
    main()  # atgriežas pie pirmā, veidojot infinite loop, līdz tiek dota 5 komanda